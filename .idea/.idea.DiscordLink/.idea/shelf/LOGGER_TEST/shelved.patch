Index: DiscordLink/Source/Core/DiscordClient.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using DSharpPlus;\r\nusing DSharpPlus.Entities;\r\nusing DSharpPlus.EventArgs;\r\nusing DSharpPlus.Exceptions;\r\nusing DSharpPlus.SlashCommands;\r\nusing Eco.Core.Utils;\r\nusing Eco.Moose.Tools.Logger;\r\nusing Eco.Plugins.DiscordLink.Events;\r\nusing Eco.Plugins.DiscordLink.Extensions;\r\nusing Eco.Plugins.DiscordLink.Utilities;\r\nusing Eco.Shared.Utils;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Eco.Plugins.DiscordLink\r\n{\r\n    public class DiscordClient\r\n    {\r\n        public enum ConnectionState\r\n        {\r\n            Disconnected,\r\n            Connecting,\r\n            Connected\r\n        }\r\n\r\n        public enum ConnectionError\r\n        {\r\n            None,\r\n            InvalidToken,\r\n            InvalidGuild,\r\n            CreateClientFailed,\r\n            DiscordConnectionFailed,\r\n            GuildConnectionFailed,\r\n            ConnectionAbortedMissingIntents,\r\n            ConnectionAborted,\r\n        }\r\n\r\n        public DSharpPlus.DiscordClient DSharpClient { get; private set; }\r\n        public DateTime LastConnectionTime { get; private set; } = DateTime.MinValue;\r\n        public ConnectionState ConnectionStatus { get; private set; } = ConnectionState.Disconnected;\r\n        public ConnectionError LastConnectionError { get; private set; } = ConnectionError.None;\r\n        public DiscordGuild Guild { get; private set; } = null;\r\n        public DiscordMember BotMember { get; private set; } = null;\r\n\r\n        public string Status\r\n        {\r\n            get { return _status; }\r\n            private set\r\n            {\r\n                Logger.Debug($\"Discord Client status changed from \\\"{_status}\\\" to \\\"{value}\\\"\");\r\n                _status = value;\r\n            }\r\n        }\r\n        private string _status = \"Uninitialized\";\r\n        private SlashCommandsExtension _commands = null;\r\n\r\n        #region Connection Handling\r\n\r\n        public ThreadSafeAction OnConnecting = new ThreadSafeAction();\r\n        public ThreadSafeAction OnConnected = new ThreadSafeAction();\r\n\r\n        public ThreadSafeAction OnDisconnecting = new ThreadSafeAction();\r\n        public ThreadSafeAction OnDisconnected = new ThreadSafeAction();\r\n\r\n        public async Task Start()\r\n        {\r\n            Logger.Debug(\"Client Starting\");\r\n\r\n            LastConnectionError = ConnectionError.None;\r\n\r\n            if (string.IsNullOrWhiteSpace(DLConfig.Data.BotToken))\r\n            {\r\n                Logger.Error(\"Bot token not configured - See Github page for install instructions.\");\r\n                LastConnectionError = ConnectionError.InvalidToken;\r\n                return; // Do not attempt to initialize if the bot token is empty\r\n            }\r\n\r\n            if (DLConfig.Data.DiscordServerID == 0)\r\n            {\r\n                Logger.Error(\"Discord Server not configured - See Github page for install instructions => \\\"https://github.com/Eco-DiscordLink/EcoDiscordPlugin\\\"\");\r\n                LastConnectionError = ConnectionError.InvalidGuild;\r\n                return; // Do not attempt to initialize if the server name/id is empty\r\n            }\r\n\r\n            if (!await CreateAndConnectClient())\r\n                return;\r\n\r\n            await Task.Delay(DLConstants.POST_SERVER_CONNECTION_WAIT_MS);\r\n            if (DSharpClient != null)\r\n                DSharpClient.SocketClosed -= HandleSocketClosedOnConnection; // Stop waiting for aborted connections caused by faulty connection attempts\r\n\r\n            if (ConnectionStatus == ConnectionState.Disconnected)\r\n            {\r\n                DSharpClient = null;\r\n                _commands = null;\r\n                Status = \"Discord connection failed\";\r\n                return; // If the second connection attempt also fails we give up\r\n            }\r\n\r\n            // Connection process continues when GuildDownloadCompleted is invoked.\r\n        }\r\n\r\n        private async Task<bool> CreateAndConnectClient()\r\n        {\r\n            Status = \"Creating Discord Client\";\r\n            ConnectionStatus = ConnectionState.Connecting;\r\n\r\n            // Create client\r\n            try\r\n            {\r\n                DSharpClient = new DSharpPlus.DiscordClient(new DiscordConfiguration\r\n                {\r\n                    AutoReconnect = true,\r\n                    Token = DLConfig.Data.BotToken,\r\n                    TokenType = TokenType.Bot,\r\n                    MinimumLogLevel = DLConfig.Data.BackendLogLevel,\r\n                    Intents = DLConstants.REQUESTED_INTENTS.Aggregate((current, next) => current | next)\r\n                });\r\n\r\n                // Register Discord commands\r\n                _commands = DSharpClient.UseSlashCommands(new SlashCommandsConfiguration());\r\n                _commands.RegisterCommands<DiscordCommands>(DLConfig.Data.DiscordServerID);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                DSharpClient = null;\r\n                _commands = null;\r\n                ConnectionStatus = ConnectionState.Disconnected;\r\n                LastConnectionError = ConnectionError.CreateClientFailed;\r\n                Status = \"Failed to create Discord Client\";\r\n                Logger.Exception($\"Error occurred while creating the Discord client\", e);\r\n                return false;\r\n            }\r\n\r\n            DSharpClient.SocketClosed += HandleSocketClosedOnConnection;\r\n\r\n            // Connect client\r\n            Status = \"Connecting to Discord...\";\r\n            OnConnecting.Invoke();\r\n            try\r\n            {\r\n                await DSharpClient.ConnectAsync(new DiscordActivity(MessageBuilder.Discord.GetActivityString(), ActivityType.Watching));\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                if (e.InnerException is UnauthorizedException)\r\n                {\r\n                    Logger.Error($\"An authentication error occurred while connecting to Discord using token \\\"{DLConfig.Data.BotToken}\\\". Please verify that your token is valid. See Github page for install instructions.\");\r\n                }\r\n                else\r\n                {\r\n                    Logger.Exception($\"An error occurred while connecting to Discord\", e);\r\n                }\r\n\r\n                DSharpClient = null;\r\n                _commands = null;\r\n                ConnectionStatus = ConnectionState.Disconnected;\r\n                LastConnectionError = ConnectionError.DiscordConnectionFailed;\r\n                Status = \"Discord connection failed\";\r\n\r\n                return false;\r\n            }\r\n\r\n            DSharpClient.GuildDownloadCompleted += HandleGuildDownloadCompleted;\r\n\r\n            return true;\r\n        }\r\n\r\n        private async Task HandleGuildDownloadCompleted(DSharpPlus.DiscordClient client, GuildDownloadCompletedEventArgs args)\r\n        {\r\n            Status = \"Resolving Discord server...\";\r\n            Guild = DSharpClient.Guilds.Values.FirstOrDefault(guild => guild.Id == DLConfig.Data.DiscordServerID);\r\n\r\n            if (Guild == null)\r\n            {\r\n                DSharpClient = null;\r\n                _commands = null;\r\n                ConnectionStatus = ConnectionState.Disconnected;\r\n                LastConnectionError = ConnectionError.GuildConnectionFailed;\r\n                Status = \"Failed to find configured Discord server\";\r\n                Logger.Error($\"Failed to find Discord server \\\"{DLConfig.Data.DiscordServerID}\\\". Make sure the Bot is invited to your Server and the Server ID is correct. See Github page for install instructions.\");\r\n                return;\r\n            }\r\n\r\n            BotMember = Guild.CurrentMember;\r\n            ConnectionStatus = ConnectionState.Connected;\r\n            Status = \"Connected to Discord\";\r\n            LastConnectionTime = DateTime.Now;\r\n\r\n            RegisterEventListeners();\r\n            OnConnected?.Invoke();\r\n        }\r\n\r\n        public async Task<bool> Stop()\r\n        {\r\n            UnregisterEventListeners();\r\n\r\n            // Disconnect\r\n            Status = \"Disconnecting from Discord\";\r\n            OnDisconnecting?.Invoke();\r\n            try\r\n            {\r\n                await DSharpClient.DisconnectAsync();\r\n                DSharpClient.Dispose();\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"An error occurred when disconnecting from Discord\", e);\r\n                Status = \"Discord disconnection failed\";\r\n                return false;\r\n            }\r\n\r\n            DSharpClient = null;\r\n            ConnectionStatus = ConnectionState.Disconnected;\r\n            Status = \"Disconnected from Discord\";\r\n            Guild = null;\r\n            BotMember = null;\r\n\r\n            OnDisconnected?.Invoke();\r\n            await DiscordLink.Obj.HandleEvent(DLEventType.DiscordClientDisconnected);\r\n            return true;\r\n        }\r\n\r\n        public async Task<bool> Restart()\r\n        {\r\n            Status = \"Restarting...\";\r\n\r\n            if (ConnectionStatus == ConnectionState.Connected || ConnectionStatus == ConnectionState.Connecting)\r\n                await Stop();\r\n\r\n            if (ConnectionStatus == ConnectionState.Disconnected)\r\n                await Start();\r\n\r\n            return ConnectionStatus == ConnectionState.Connected;\r\n        }\r\n\r\n        private void RegisterEventListeners()\r\n        {\r\n            DSharpClient.ClientErrored += HandleClientError;\r\n            DSharpClient.SocketErrored += HandleSocketError;\r\n            DSharpClient.MessageCreated += HandleDiscordMessageCreated;\r\n            DSharpClient.MessageUpdated += HandleDiscordMessageEdited;\r\n            DSharpClient.MessageDeleted += HandleDiscordMessageDeleted;\r\n            DSharpClient.MessageReactionAdded += HandleDiscordReactionAdded;\r\n            DSharpClient.MessageReactionRemoved += HandleDiscordReactionRemoved;\r\n        }\r\n\r\n        private void UnregisterEventListeners()\r\n        {\r\n            DSharpClient.ClientErrored -= HandleClientError;\r\n            DSharpClient.SocketErrored -= HandleSocketError;\r\n            DSharpClient.MessageCreated -= HandleDiscordMessageCreated;\r\n            DSharpClient.MessageUpdated -= HandleDiscordMessageEdited;\r\n            DSharpClient.MessageDeleted -= HandleDiscordMessageDeleted;\r\n            DSharpClient.MessageReactionAdded -= HandleDiscordReactionAdded;\r\n            DSharpClient.MessageReactionRemoved -= HandleDiscordReactionRemoved;\r\n        }\r\n\r\n        #endregion\r\n\r\n        #region Event Handlers\r\n\r\n        private async Task HandleDiscordMessageCreated(DSharpPlus.DiscordClient client, MessageCreateEventArgs args)\r\n        {\r\n            DiscordMessage message = args.Message;\r\n            Logger.Trace($\"Discord Message Received\\n{message.FormatForLog()}\");\r\n\r\n            if (args.Author == DSharpClient.CurrentUser)\r\n                return; // Ignore messages sent by our own bot\r\n\r\n            await DiscordLink.Obj.HandleEvent(DLEventType.DiscordMessageSent, message);\r\n        }\r\n\r\n        private async Task HandleDiscordMessageEdited(DSharpPlus.DiscordClient client, MessageUpdateEventArgs args)\r\n        {\r\n            if (args.Author == DSharpClient.CurrentUser)\r\n                return; // Ignore messages edits made by our own bot\r\n\r\n            await DiscordLink.Obj.HandleEvent(DLEventType.DiscordMessageEdited, args.Message, args.MessageBefore);\r\n        }\r\n\r\n        private async Task HandleDiscordMessageDeleted(DSharpPlus.DiscordClient client, MessageDeleteEventArgs args)\r\n        {\r\n            await DiscordLink.Obj.HandleEvent(DLEventType.DiscordMessageDeleted, args.Message);\r\n        }\r\n\r\n        private async Task HandleDiscordReactionAdded(DSharpPlus.DiscordClient client, MessageReactionAddEventArgs args)\r\n        {\r\n            if (args.User == client.CurrentUser)\r\n                return; // Ignore reactions sent by our own bot\r\n\r\n            await DiscordLink.Obj.HandleEvent(DLEventType.DiscordReactionAdded, args.User, args.Message, args.Emoji);\r\n        }\r\n\r\n        private async Task HandleDiscordReactionRemoved(DSharpPlus.DiscordClient client, MessageReactionRemoveEventArgs args)\r\n        {\r\n            if (args.User == client.CurrentUser)\r\n                return; // Ignore reactions sent by our own bot\r\n\r\n            await DiscordLink.Obj.HandleEvent(DLEventType.DiscordReactionRemoved, args.User, args.Message, args.Emoji);\r\n        }\r\n\r\n        private async Task HandleClientError(DSharpPlus.DiscordClient client, ClientErrorEventArgs args)\r\n        {\r\n            Logger.DebugException($\"A Discord client error occurred. Event: \\\"{args.EventName}\\\"\", args.Exception);\r\n        }\r\n\r\n        private async Task HandleSocketError(DSharpPlus.DiscordClient client, SocketErrorEventArgs args)\r\n        {\r\n            Logger.DebugException($\"A socket error occurred\", args.Exception);\r\n        }\r\n\r\n        private async Task HandleSocketClosedOnConnection(DSharpPlus.DiscordClient client, SocketCloseEventArgs args)\r\n        {\r\n            if (args.CloseCode == 4014) // Application does not have the requested privileged intents\r\n            {\r\n                Logger.Error(\"Bot application is not configured to have the required intents. See install instructions for help with adding intents.\");\r\n                LastConnectionError = ConnectionError.ConnectionAbortedMissingIntents;\r\n            }\r\n            else\r\n            {\r\n                LastConnectionError = ConnectionError.ConnectionAborted;\r\n            }\r\n            ConnectionStatus = ConnectionState.Disconnected;\r\n        }\r\n\r\n        #endregion\r\n\r\n        #region Information Fetching\r\n\r\n        public DiscordGuild GuildByNameOrID(string guildNameOrID)\r\n        {\r\n            return guildNameOrID.TryParseSnowflakeID(out ulong ID)\r\n                ? DSharpClient.Guilds.Values.FirstOrDefault(guild => guild.Id == ID)\r\n                : DSharpClient.Guilds.Values.FirstOrDefault(guild => guild.Name.EqualsCaseInsensitive(guildNameOrID));\r\n        }\r\n\r\n        public DiscordChannel ChannelByNameOrID(string channelNameOrID)\r\n        {\r\n            return channelNameOrID.TryParseSnowflakeID(out ulong ID)\r\n                ? Guild.Channels.Values.FirstOrDefault(channel => channel.Id == ID)\r\n                : Guild.Channels.Values.FirstOrDefault(guild => guild.Name.EqualsCaseInsensitive(channelNameOrID));\r\n        }\r\n\r\n        public bool ChannelHasPermission(DiscordChannel channel, Permissions permission)\r\n        {\r\n            if (BotMember == null)\r\n            {\r\n                Logger.Error($\"BotMember was null when evaluating channel permissions for channel \\\"{channel.Name}\\\"\");\r\n                return false;\r\n            }\r\n\r\n            if (channel.IsPrivate)\r\n                return true; // Assume permission is given for DMs\r\n\r\n            return channel.PermissionsFor(BotMember).HasPermission(permission);\r\n        }\r\n\r\n        public bool BotHasPermission(Permissions permission)\r\n        {\r\n            if (BotMember == null)\r\n            {\r\n                Logger.Error($\"BotMember was null when evaluating bot permissions\");\r\n                return false;\r\n            }\r\n\r\n            bool hasPermission = false;\r\n            foreach (DiscordRole role in BotMember.Roles)\r\n            {\r\n                if (role.CheckPermission(permission) == PermissionLevel.Allowed)\r\n                {\r\n                    hasPermission = true;\r\n                    break;\r\n                }\r\n            }\r\n            return hasPermission;\r\n        }\r\n\r\n        public bool BotHasIntent(DiscordIntents intent)\r\n        {\r\n            return (DSharpClient.Intents & intent) != 0;\r\n        }\r\n\r\n        public bool MemberIsAdmin(DiscordMember member)\r\n        {\r\n            foreach (string adminRole in DLConfig.Data.AdminRoles)\r\n            {\r\n                if (adminRole.TryParseSnowflakeID(out ulong adminRoleID) && member.Roles.Any(role => role.Id == adminRoleID))\r\n                    return true;\r\n\r\n                if (member.Roles.Any(role => role.Name.EqualsCaseInsensitive(adminRole)))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public IEnumerable<Permissions> FindMissingGuildPermissions()\r\n        {\r\n            List<Permissions> missingPermissions = new List<Permissions>();\r\n            foreach (Permissions permission in DLConstants.REQUESTED_GUILD_PERMISSIONS)\r\n            {\r\n                if (!BotHasPermission(permission))\r\n                    missingPermissions.Add(permission);\r\n            }\r\n            return missingPermissions;\r\n        }\r\n\r\n        public IEnumerable<Permissions> FindMissingChannelPermissions(DiscordChannel channel)\r\n        {\r\n            List<Permissions> missingPermissions = new List<Permissions>();\r\n            foreach (Permissions permission in DLConstants.REQUESTED_CHANNEL_PERMISSIONS)\r\n            {\r\n                if (!ChannelHasPermission(channel, permission))\r\n                    missingPermissions.Add(permission);\r\n            }\r\n            return missingPermissions;\r\n        }\r\n\r\n        public IEnumerable<DiscordIntents> FindMissingIntents()\r\n        {\r\n            List<DiscordIntents> missingIntents = new List<DiscordIntents>();\r\n            foreach (DiscordIntents intent in DLConstants.REQUESTED_INTENTS)\r\n            {\r\n                if (!BotHasIntent(intent))\r\n                    missingIntents.Add(intent);\r\n            }\r\n            return missingIntents;\r\n        }\r\n\r\n        public async Task<DiscordUser> GetUserAsync(string userID)\r\n        {\r\n            if (!userID.TryParseSnowflakeID(out ulong ID))\r\n                return null;\r\n\r\n            return await GetUserAsync(ID);\r\n        }\r\n\r\n        public async Task<DiscordUser> GetUserAsync(ulong userID)\r\n        {\r\n            try\r\n            {\r\n                Logger.Trace($\"Fetching user with ID \\\"{userID}\\\"\");\r\n                return await DSharpClient.GetUserAsync(userID);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred when attempting to fetch user with ID \\\"{userID}\\\"\", e);\r\n                return null;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Error occurred when attempting to fetch user with ID \\\"{userID}\\\"\", e);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public async Task<DiscordMember> GetMemberAsync(string userID)\r\n        {\r\n            if (!userID.TryParseSnowflakeID(out ulong ID))\r\n                return null;\r\n\r\n            return await GetMemberAsync(Guild, ID);\r\n        }\r\n\r\n        public async Task<DiscordMember> GetMemberAsync(DiscordGuild guild, ulong memberID)\r\n        {\r\n            try\r\n            {\r\n                Logger.Trace($\"Fetching member with ID \\\"{memberID}\\\"\");\r\n                return await Guild.GetMemberAsync(memberID);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred when attempting to fetch member with ID \\\"{memberID}\\\"\", e);\r\n                return null;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Error occurred when attempting to fetch member with ID \\\"{memberID}\\\"\", e);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public async Task<DiscordMessage> GetMessageAsync(DiscordChannel channel, ulong messageID)\r\n        {\r\n            if (!ChannelHasPermission(channel, Permissions.ReadMessageHistory))\r\n                return null;\r\n\r\n            try\r\n            {\r\n                Logger.Trace($\"Fetching message with ID \\\"{messageID}\\\" from channel \\\"{channel.Name}\\\"\");\r\n                return await channel.GetMessageAsync(messageID);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred when attempting to read message with ID {messageID} from channel \\\"{channel.Name}\\\"\", e);\r\n                return null;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Error occurred when attempting to read message with ID {messageID} from channel \\\"{channel.Name}\\\"\", e);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public async Task<IReadOnlyList<DiscordMessage>> GetMessagesAsync(DiscordChannel channel)\r\n        {\r\n            if (channel == null || !ChannelHasPermission(channel, Permissions.ReadMessageHistory))\r\n                return null;\r\n\r\n            try\r\n            {\r\n                Logger.Trace($\"Fetching recent messages from channel \\\"{channel.Name}\\\"\");\r\n                return await channel.GetMessagesAsync();\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while fetching messages from channel \\\"{channel.Name}\", e);\r\n                return null;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Error occurred when attempting to read message history from channel \\\"{channel.Name}\\\"\", e);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        public async Task<IReadOnlyCollection<DiscordMember>> GetGuildMembersAsync()\r\n        {\r\n            if (!BotHasIntent(DiscordIntents.GuildMembers))\r\n            {\r\n                Logger.Error(\"Attempted to get full guild member list but the bot does not have the privileged GuildMembers intent\");\r\n                return null;\r\n            }\r\n\r\n            try\r\n            {\r\n                Logger.Trace(\"Fetching guild member list\");\r\n                return await Guild.GetAllMembersAsync();\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while fetching guild members\", e);\r\n                return null;\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Error occured when attempting to fetch all guild members\", e);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        #endregion\r\n\r\n        #region Manipulation\r\n\r\n        public async Task<DiscordMessage> SendMessageAsync(DiscordChannel channel, string textContent, DiscordLinkEmbed embedContent = null)\r\n        {\r\n            if (channel == null)\r\n                return null;\r\n\r\n            DiscordMessage createdMessage = null;\r\n            try\r\n            {\r\n                if (!ChannelHasPermission(channel, Permissions.SendMessages))\r\n                {\r\n                    Logger.Warning($\"Attempted to send message to channel `{channel}` but the bot user is lacking permissions for this action\");\r\n                    return null;\r\n                }\r\n\r\n                // Either make sure we have permission to use embeds or convert the embed to text\r\n                string fullTextContent = (embedContent == null || ChannelHasPermission(channel, Permissions.EmbedLinks)) ? textContent : $\"{textContent}\\n{embedContent.AsText()}\";\r\n\r\n                // If needed; split the message into multiple parts\r\n                ICollection<string> stringParts = MessageUtils.SplitStringBySize(fullTextContent, DLConstants.DISCORD_MESSAGE_CHARACTER_LIMIT);\r\n                ICollection<DiscordEmbed> embedParts = MessageUtils.BuildDiscordEmbeds(embedContent);\r\n\r\n                Logger.Trace($\"Sending message to channel \\\"{channel.Name}\\\" containing {stringParts.Count} raw string parts and {embedParts.Count} embed parts\");\r\n                if (stringParts.Count <= 1 && embedParts.Count == 1)\r\n                {\r\n                    createdMessage = await channel.SendMessageAsync(fullTextContent, embedParts.First());\r\n                }\r\n                else\r\n                {\r\n                    foreach (string textMessagePart in stringParts)\r\n                    {\r\n                        createdMessage = await channel.SendMessageAsync(textMessagePart);\r\n                    }\r\n                    foreach (DiscordEmbed embedPart in embedParts)\r\n                    {\r\n                        createdMessage = await channel.SendMessageAsync(embedPart);\r\n                    }\r\n                }\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while sending message to channel \\\"{channel.Name}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Failed to send message to channel {channel.Name}\", e);\r\n            }\r\n            return createdMessage;\r\n        }\r\n\r\n        public async Task<DiscordMessage> SendDMAsync(DiscordMember targetMember, string textContent, DiscordLinkEmbed embedContent = null)\r\n        {\r\n            if (targetMember == null)\r\n                return null;\r\n\r\n            DiscordMessage createdMessage = null;\r\n            try\r\n            {\r\n                // If needed; split the message into multiple parts\r\n                ICollection<string> stringParts = MessageUtils.SplitStringBySize(textContent, DLConstants.DISCORD_MESSAGE_CHARACTER_LIMIT);\r\n                ICollection<DiscordEmbed> embedParts = MessageUtils.BuildDiscordEmbeds(embedContent);\r\n\r\n                Logger.Trace($\"Sending DM to user \\\"{targetMember.Username}\\\" containing {stringParts.Count} raw string parts and {embedParts.Count} embed parts\");\r\n                if (stringParts.Count <= 1 && embedParts.Count <= 1)\r\n                {\r\n                    DiscordEmbed embed = (embedParts.Count >= 1) ? embedParts.First() : null;\r\n                    createdMessage = await targetMember.SendMessageAsync(textContent, embed);\r\n                }\r\n                else\r\n                {\r\n                    foreach (string textMessagePart in stringParts)\r\n                    {\r\n                        createdMessage = await targetMember.SendMessageAsync(textMessagePart, null);\r\n                    }\r\n                    foreach (DiscordEmbed embedPart in embedParts)\r\n                    {\r\n                        createdMessage = await targetMember.SendMessageAsync(null, embedPart);\r\n                    }\r\n                }\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while sending message to member \\\"{targetMember.Username}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Failed to send DM message to {targetMember.Username}\", e);\r\n            }\r\n            return createdMessage;\r\n        }\r\n\r\n        public async Task<DiscordMessage> ModifyMessageAsync(DiscordMessage message, string textContent, DiscordLinkEmbed embedContent = null)\r\n        {\r\n            if (message == null)\r\n                return null;\r\n\r\n            DiscordMessage editedMessage = null;\r\n            try\r\n            {\r\n                DiscordChannel channel = message.GetChannel();\r\n                if (!ChannelHasPermission(channel, Permissions.ManageMessages))\r\n                {\r\n                    Logger.Error($\"Attempted to modify message in channel `{channel}` but the bot user is lacking permissions for this action\");\r\n                    return null;\r\n                }\r\n\r\n                if (embedContent == null)\r\n                {\r\n                    Logger.Trace($\"Editing raw message in channel \\\"{message.Channel.Name}\\\"\");\r\n                    editedMessage = await message.ModifyAsync(textContent);\r\n                }\r\n                else\r\n                {\r\n                    // Either make sure we have permission to use embeds or convert the embed to text\r\n                    if (ChannelHasPermission(channel, Permissions.EmbedLinks))\r\n                    {\r\n                        List<DiscordEmbed> splitEmbeds = MessageUtils.BuildDiscordEmbeds(embedContent);\r\n                        Logger.Trace($\"Editing embed message with {splitEmbeds.Count} pieces in channel \\\"{message.Channel.Name}\\\"\");\r\n                        if (splitEmbeds.Count > 0)\r\n                            editedMessage = await message.ModifyAsync(textContent, splitEmbeds[0]); // TODO: Actually keep track of split messages instead of only overwriting the first one\r\n                    }\r\n                    else\r\n                    {\r\n                        Logger.Trace($\"Editing converted embed message with in channel \\\"{message.Channel.Name}\\\"\");\r\n                        await message.ModifyEmbedSuppressionAsync(true); // Remove existing embeds\r\n                        editedMessage = await message.ModifyAsync($\"{textContent}\\n{embedContent.AsText()}\");\r\n                    }\r\n                }\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while modifying message in channel \\\"{message.Channel.Name}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                string channelName = message?.Channel?.Name;\r\n                if (string.IsNullOrWhiteSpace(channelName))\r\n                    channelName = \"Unknown channel\";\r\n\r\n                Logger.Exception($\"Failed to modify message in channel \\\"{channelName}\\\"\", e);\r\n            }\r\n            return editedMessage;\r\n        }\r\n\r\n        public async Task<bool> DeleteMessageAsync(DiscordMessage message)\r\n        {\r\n            if (message == null)\r\n                return false;\r\n\r\n            DiscordChannel channel = message.GetChannel();\r\n            if (!ChannelHasPermission(channel, Permissions.ManageMessages))\r\n            {\r\n                Logger.Warning($\"Attempted to delete message in channel \\\"{channel}\\\" but the bot user is lacking permissions for this action\");\r\n                return false;\r\n            }\r\n\r\n            bool result = false;\r\n            try\r\n            {\r\n                Logger.Trace($\"Deleting message \\\"{message.Id}\\\" from channel \\\"{channel.Name}\\\"\");\r\n                await message.DeleteAsync(\"Deleted by DiscordLink\");\r\n                result = true;\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while deleting message in channel \\\"{message.Channel.Name}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                string channelName = message?.Channel?.Name;\r\n                if (string.IsNullOrWhiteSpace(channelName))\r\n                    channelName = \"Unknown channel\";\r\n\r\n                Logger.Exception($\"Failed to delete message from channel \\\"{channelName}\\\"\", e);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        public async Task<DiscordRole> CreateRoleAsync(DiscordLinkRole dlRole)\r\n        {\r\n            try\r\n            {\r\n                Logger.Trace($\"Creating role \\\"{dlRole.Name}\\\"\");\r\n                DiscordRole role = await Guild.CreateRoleAsync(dlRole.Name, dlRole.Permissions, dlRole.Color, dlRole.Hoist, dlRole.Mentionable, dlRole.AddReason);\r\n                if (role != null)\r\n                {\r\n                    DLStorage.PersistentData.RoleIDs.Add(role.Id);\r\n                    DLStorage.Instance.Write(); // Save immediately after creating so that we don't lose track of the roles in case of an ungraceful exit\r\n                }\r\n                else\r\n                {\r\n                    Logger.Error($\"Failed to create role \\\"{dlRole.Name}\\\".\");\r\n                }\r\n\r\n                return role;\r\n            }\r\n            catch (UnauthorizedException e)\r\n            {\r\n                Logger.Exception($\"DiscordLink was not allowed to create the role \\\"{dlRole.Name}\\\". Ensure that your bot user is assigned a role with higher permission level than all roles it manages.\", e);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while creating role \\\"{dlRole.Name}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Failed to create role \\\"{dlRole.Name}\\\"\", e);\r\n            }\r\n            return await Task.FromResult<DiscordRole>(null);\r\n        }\r\n\r\n        public async Task AddRoleAsync(DiscordMember member, DiscordLinkRole dlRole)\r\n        {\r\n            DiscordRole discordRole = Guild.RoleByName(dlRole.Name);\r\n            if (discordRole == null)\r\n                discordRole = await CreateRoleAsync(dlRole);\r\n\r\n            if (discordRole != null)\r\n                await AddRoleAsync(member, discordRole);\r\n        }\r\n\r\n        public async Task AddRoleAsync(DiscordMember member, DiscordRole role)\r\n        {\r\n            if (member == null || role == null)\r\n                return;\r\n            if (member.HasRole(role))\r\n                return; // Member already has the role\r\n\r\n            try\r\n            {\r\n                Logger.Trace($\"Adding role \\\"{role.Name}\\\" to member \\\"{member.Username}\\\"\");\r\n                await member.GrantRoleAsync(role, \"Added by DiscordLink\");\r\n            }\r\n            catch (UnauthorizedException e)\r\n            {\r\n                Logger.Exception($\"DiscordLink was not allowed to grant the role \\\"{role.Name}\\\" to member \\\"{member.Username}\\\". Ensure that your bot user is assigned a role with higher permission level than all roles it manages.\", e);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while adding role \\\"{role.Name}\\\" to member \\\"{member.Username}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Failed to grant role \\\"{role.Name}\\\" to member \\\"{member.Username}\\\"\", e);\r\n            }\r\n        }\r\n\r\n        public async Task RemoveRoleAsync(DiscordMember member, string roleName)\r\n        {\r\n            DiscordRole role = Guild.RoleByName(roleName);\r\n            if (role == null)\r\n            {\r\n                Logger.Debug($\"Attempting to remove nonexistent role \\\"{roleName}\\\" from user \\\"{member.DisplayName}\\\"\");\r\n                return;\r\n            }\r\n\r\n            await RemoveRoleAsync(member, role);\r\n        }\r\n\r\n        public async Task RemoveRoleAsync(DiscordMember member, DiscordRole role)\r\n        {\r\n            if (member == null || role == null)\r\n                return;\r\n            if (!member.HasRole(role))\r\n                return; // Member doesn't have the role\r\n\r\n            try\r\n            {\r\n                Logger.Trace($\"Removing role \\\"{role.Name}\\\" from member \\\"{member.Username}\\\"\");\r\n                await member.RevokeRoleAsync(role, \"Removed by DiscordLink\");\r\n            }\r\n            catch (UnauthorizedException e)\r\n            {\r\n                Logger.Exception($\"DiscordLink was not allowed to revoke the role \\\"{role.Name}\\\" from member \\\"{member.Username}\\\". Ensure that your bot user is assigned a role with higher permission level than all roles it manages.\", e);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while removing role \\\"{role.Name}\\\" from member \\\"{member.Username}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Failed to revoke role \\\"{role.Name}\\\" from member \\\"{member.Username}\\\"\", e);\r\n            }\r\n        }\r\n\r\n        public async Task DeleteRoleAsync(DiscordRole role)\r\n        {\r\n            if (role == null)\r\n                return;\r\n\r\n            try\r\n            {\r\n                Logger.Trace($\"Deleting role \\\"{role.Name}\\\"\");\r\n                await role.DeleteAsync(\"Deleted by DiscordLink\");\r\n            }\r\n            catch (UnauthorizedException e)\r\n            {\r\n                Logger.Exception($\"DiscordLink was not allowed to delete the role \\\"{role.Name}\\\". Ensure that your bot user is assigned a role with higher permission level than all roles it manages.\", e);\r\n            }\r\n            catch (ServerErrorException e)\r\n            {\r\n                Logger.DebugException($\"ServerErrorException occurred while deleting role \\\"{role.Name}\\\"\", e);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Logger.Exception($\"Failed to delete role \\\"{role.Name}\\\"\", e);\r\n            }\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DiscordLink/Source/Core/DiscordClient.cs b/DiscordLink/Source/Core/DiscordClient.cs
--- a/DiscordLink/Source/Core/DiscordClient.cs	(revision d4f1cc889093aef3f49def260f19141a6d5086bf)
+++ b/DiscordLink/Source/Core/DiscordClient.cs	(date 1708073040327)
@@ -116,6 +116,7 @@
                     Token = DLConfig.Data.BotToken,
                     TokenType = TokenType.Bot,
                     MinimumLogLevel = DLConfig.Data.BackendLogLevel,
+                    LoggerFactory = new MightyMooseFileLoggerFactory(DLConfig.Data.BackendLogLevel),
                     Intents = DLConstants.REQUESTED_INTENTS.Aggregate((current, next) => current | next)
                 });
 
Index: DiscordLink/Source/Logging/MightyMooseFileLogger.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DiscordLink/Source/Logging/MightyMooseFileLogger.cs b/DiscordLink/Source/Logging/MightyMooseFileLogger.cs
new file mode 100644
--- /dev/null	(date 1708073068785)
+++ b/DiscordLink/Source/Logging/MightyMooseFileLogger.cs	(date 1708073068785)
@@ -0,0 +1,64 @@
+using System;
+using Eco.Moose.Tools.Logger;
+using Microsoft.Extensions.Logging;
+
+namespace Eco.Plugins.DiscordLink;
+
+/**
+ * Implements the Microsoft Logging interface to call the MightyMoose Logger.
+ */
+public class MightyMooseFileLogger : ILogger
+{
+    private readonly LogLevel _minimumLevel;
+
+    public MightyMooseFileLogger(LogLevel minLevel)
+    {
+        _minimumLevel = minLevel;
+    }
+
+    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception,
+        Func<TState, Exception, string> formatter)
+    {
+        var message = formatter.ToString();
+        if (message == null || !IsEnabled(logLevel))
+        {
+            return;
+        }
+
+        switch (logLevel)
+        {
+            case LogLevel.Trace:
+                Logger.Trace(message);
+                break;
+            case LogLevel.Debug:
+                Logger.Debug(message);
+                break;
+            case LogLevel.Information:
+                Logger.Info(message);
+                break;
+            case LogLevel.Warning:
+                Logger.Warning(message);
+                break;
+            case LogLevel.Error:
+                Logger.Error(message);
+                break;
+            case LogLevel.Critical:
+                Logger.Error(message);
+                break;
+            case LogLevel.None:
+                break;
+
+            default:
+                Logger.Info(message);
+                break;
+        }
+    }
+
+    public bool IsEnabled(LogLevel logLevel)
+        => logLevel >= _minimumLevel;
+
+    /**
+     * Not needed
+     */
+    public IDisposable BeginScope<TState>(TState state) => throw new NotImplementedException();
+}
\ No newline at end of file
Index: DiscordLink/Source/Logging/MightyMooseFileLoggerFactory.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/DiscordLink/Source/Logging/MightyMooseFileLoggerFactory.cs b/DiscordLink/Source/Logging/MightyMooseFileLoggerFactory.cs
new file mode 100644
--- /dev/null	(date 1708073040338)
+++ b/DiscordLink/Source/Logging/MightyMooseFileLoggerFactory.cs	(date 1708073040338)
@@ -0,0 +1,35 @@
+using Eco.Moose.Tools.Logger;
+using Microsoft.Extensions.Logging;
+
+namespace Eco.Plugins.DiscordLink;
+
+/**
+ * Factory Class for Loggers, which redirect their Output to the MightyMoose Implementation. This will always Log everything to File.
+ */
+public class MightyMooseFileLoggerFactory : ILoggerFactory
+{
+    private LogLevel MinimumLevel { get; }
+
+    public MightyMooseFileLoggerFactory(LogLevel minimumLevel)
+    {
+        MinimumLevel = minimumLevel;
+    }
+
+    public void Dispose()
+    {
+       // Nothing to dispose
+    }
+
+    public ILogger CreateLogger(string categoryName)
+    {
+        return new MightyMooseFileLogger(MinimumLevel);
+    }
+
+    public void AddProvider(ILoggerProvider provider)
+    {
+        // we don't really need that for our simple use case
+        Logger.Warning("Tried to add a Log-Provider, which is not Supported right now.");
+    }
+    
+    
+}
\ No newline at end of file
